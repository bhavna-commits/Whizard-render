import crypto from "crypto";
import Token from "../../models/token.model.js";
import { generateUniqueId } from "../../utils/otpGenerator.js";

// Mapping for digits to letters
const digitToLetter = {
	0: "Z",
	1: "J",
	2: "j",
	3: "K",
	4: "l",
	5: "L",
	6: "m",
	7: "M",
	8: "n",
	9: "N",
};

// Reverse mapping for decoding letters back to digits
const letterToDigit = {
	Z: "0",
	J: "1",
	j: "2",
	K: "3",
	l: "4",
	L: "5",
	m: "6",
	M: "7",
	n: "8",
	N: "9",
};

// Helper function to extract userId from the token record.
export async function getUserIdFromToken(req, res, next) {
    const token = req.body?.token;
    if (!token) {
        res.status(400).json({ message: "Token not provided" });
        return;
    }
    if (!isString(token)) return next();
    try {
        const tokenData = await validateToken(token);
        return tokenData.userId;
    } catch (err) {
        res.status(400).json({
            success: false,
            message: err || "Token error",
        });
    }
}

/**
 * Generates a token by inserting mapped characters from the [timestampStr] into the [baseHash].
 * Insertion is done in reverse order so that each insertion does not affect the positions of earlier ones.
 * Each digit is mapped using the digitToLetter mapping and inserted at position: pos = 3 + 4 * i.
 * @param {string} baseHash - The original hash string.
 * @param {string} timestampStr - The timestamp string (digits) to be inserted.
 * @returns {string} The generated token.
 */
function generateTokenFromHash(baseHash, timestampStr) {
	const mapped = timestampStr.split("").map(digit => digitToLetter[digit] || digit);
	let token = baseHash;
	// Insert letters in reverse order.
	for (let i = mapped.length - 1; i >= 0; i--) {
		const pos = 3 + 4 * i;
		token = token.slice(0, pos) + mapped[i] + token.slice(pos);
	}
	return token;
}

/**
 * Decodes the token by extracting the inserted timestamp characters.
 * Since each insertion causes the final positions of the inserted characters to be:
 *   pos = 3 + 5 * i   for i from 0 to (insertionCount - 1),
 * this function removes those characters (in descending order) so that:
 *   - The removed letters (mapped back via letterToDigit) form the original timestamp.
 *   - The remaining characters form the base hash.
 * @param {string} token - The token generated by generateTokenFromHash.
 * @param {number} insertionCount - The number of characters inserted (i.e. length of timestampStr).
 * @returns {Object} An object containing:
 *    - timestamp: The decoded timestamp string.
 *    - baseHash: The original hash with the inserted characters removed.
 */
function decodeToken(token, insertionCount = 13) {
	const tokenArray = token.split('');
	const extracted = [];
	// Remove inserted characters in descending order to avoid affecting indices.
	for (let i = insertionCount - 1; i >= 0; i--) {
		// Final inserted positions: pos = 3 + 5 * i.
		const pos = 3 + 5 * i;
		const removed = tokenArray.splice(pos, 1)[0];
		extracted.push(removed);
	}
	// Reverse to restore the original order.
	extracted.reverse();
	// Map each extracted letter back to its corresponding digit.
	const timestampDigits = extracted.map(letter => letterToDigit[letter] || letter);
	const timestamp = timestampDigits.join('');
	// The remaining tokenArray is the base hash.
	const baseHashResult = tokenArray.join('');
	return { timestamp, baseHash: baseHashResult };
}

/**
 * Generates a new token by creating a 64-character base hash, encoding the current epoch timestamp,
 * and inserting the mapped letters into the base hash.
 *
 * @returns {Object} - Contains the final token, its expiration timestamp, the original base hash, and the timestamp string.
 */
export function generateToken() {
	const baseHash = crypto.randomBytes(32).toString("hex"); // 64-character hex string
	const timestampStr = Date.now().toString(); // e.g., "1742368576007"
	const token = generateTokenFromHash(baseHash, timestampStr);
	// For example, token expires in 2 minutes:
	const expiresAt = Date.now() + 2 * 60 * 1000;
	return { token, expiresAt, baseHash, timestampStr };
}

/**
 * Creates and saves a new token record in the database upon user login.
 *
 * @param {string} userId - The user's ID.
 * @param {string} permission - The permission level for the user.
 * @returns {Promise<Object>} - The saved token record.
 */
export async function createTokenRecord(userId, permission, addedUser) {
	const { token, expiresAt } = generateToken();
	const unique_id = generateUniqueId();
	const newTokenRecord = new Token({
		accessToken: token,
		lastToken: null,
		userId,
		expiresAt,
		permission,
		unique_id,
		addedUser,
	});
	await newTokenRecord.save();
	return newTokenRecord;
}

/**
 * Refreshes the token by decoding its embedded timestamp, adding 30 seconds,
 * generating a new token with the updated timestamp, and updating the token record.
 * The previous token is stored in the `lastToken` field.
 *
 * @param {string} oldToken - The token to be refreshed.
 * @returns {Promise<Object>} - The updated token record.
 */
export async function refreshToken(oldToken) {
	const tokenRecord = await Token.findOne({ accessToken: oldToken });
	if (!tokenRecord) {
		throw new Error("Invalid token");
	}

	// Decode the original timestamp from the token
	const decodedTimestampStr = decodeToken(oldToken);
	const decodedTimestamp = Number(decodedTimestampStr);

	if (Date.now() > tokenRecord.expiresAt) {
		throw new Error("Token has expired");
	}

	// Add 30 seconds to the decoded timestamp
	const newTimestamp = (decodedTimestamp + 30000).toString();
	const newBaseHash = crypto.randomBytes(32).toString("hex");
	const newToken = generateTokenFromHash(newBaseHash, newTimestamp);

	// Update token record: store the current token as lastToken, update accessToken and expiration.
	tokenRecord.lastToken = tokenRecord.accessToken;
	tokenRecord.accessToken = newToken;
	tokenRecord.expiresAt = Date.now() + 2 * 60 * 1000;
	await tokenRecord.save();
	return tokenRecord;
}

/**
 * Validates a token by checking its format, verifying its existence in the database,
 * and ensuring it has not expired.
 *
 * @param {string} token - The token to validate.
 * @returns {Promise<Object>} - The valid token record.
 */
export async function validateToken(token) {
	if (!token || typeof token !== "string") {
		throw new Error("Invalid token format");
	}
	const tokenRecord = await Token.findOne({ accessToken: token });
	if (!tokenRecord) {
		throw new Error("Token not found");
	}
	if (Date.now() > tokenRecord.expiresAt) {
		throw new Error("Token has expired");
	}
	return tokenRecord;
}
